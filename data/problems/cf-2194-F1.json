{
  "title": "Again Trees... (Easy Version)",
  "slug": "cf-2194-F1",
  "difficulty": "Easy",
  "tags": [
    "bitmasks",
    "dfs and similar",
    "dp",
    "trees"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the easy version of the problem. The difference between the versions is that in this version, ğ‘˜â‰¤4. You can hack only if you solved all versions of this problem.\n\nGiven a tree consisting of ğ‘› vertices. Each vertex has a non-negative integer ğ‘ğ‘£ written on it. You are also given ğ‘˜ distinct non-negative integers ğ‘1,â€¦,ğ‘ğ‘˜.\n\nWe will call a set of edges beautiful if, after removing these edges from the tree, the tree splits into connected components, where in each component the bitwise XOR of all the numbers ğ‘ğ‘£ in that component belongs to the set ğ‘.\n\nYou need to count the number of beautiful sets of edges in the tree modulo 10^9+7109+7.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤500). The description of the test cases follows.\n\nThe first line of each dataset contains two integers ğ‘› and ğ‘˜ (2â‰¤ğ‘›â‰¤10^5, 1â‰¤ğ‘˜â‰¤4)Â â€” the number of vertices in the tree and the size of the set ğ‘.\n\nThe next ğ‘›âˆ’1 lines describe the edges of the tree. The ğ‘–-th line contains two integers ğ‘£ğ‘– and ğ‘¢ğ‘– (1â‰¤ğ‘£ğ‘–,ğ‘¢ğ‘–â‰¤ğ‘›)Â â€” the numbers of the vertices connected by the ğ‘–-th edge.\n\nThe next line contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (0â‰¤ğ‘ğ‘–\n<\n2300â‰¤ğ‘ğ‘–\n<\n230)Â â€” the values written on the vertices.\n\nThe following line contains ğ‘˜ distinct integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜ (0â‰¤ğ‘ğ‘–\n<\n2300â‰¤ğ‘ğ‘–\n<\n230)Â â€” the elements of the set ğ‘.\n\nIt is guaranteed that the sum of ğ‘› across all datasets does not exceed 10^5.",
  "output_format": "For each test dataset, output a single integer â€” the answer to the problem.",
  "constraints": "Illustration for the first test dataset. In it, you can remove the edge between vertices 1 and 2. Then the bitwise XOR in the component consisting of vertices 2 and 5 is ğ‘2\nâŠ•\nğ‘5=2âŠ•3=1 ğ‘2\nâŠ•\nğ‘5=2\nâŠ•\n3=1. The bitwise XOR in the component with vertices 1, 3, and 4 is ğ‘1\nâŠ•\nğ‘3\nâŠ•\nğ‘4=0âŠ•2âŠ•3=1 ğ‘1\nâŠ•\nğ‘3\nâŠ•\nğ‘4=0\nâŠ•\n2\nâŠ•\n3=1. The second beautiful set is the one consisting of the edge connecting vertices 1 and 3.\n\nIn the third test dataset, the beautiful sets will be (an edge is denoted by the pair of vertices it connects) [(1,2)],[(1,3)],[(2,5)],[(3,4)]\n[\n(1,2)\n]\n,\n[\n(1,3)\n]\n,\n[\n(2,5)\n]\n,\n[\n(3,4)\n]\n. Note that the first and third samples differ only in the set ğ‘.\n\nIn the fourth test dataset, the beautiful sets will be [(1,2)],[(3,4)],[(1,2),(2,3),(3,4)]\n[\n(1,2)\n]\n,\n[\n(3,4)\n]\n,\n[\n(1,2)\n,\n(2,3)\n,\n(3,4)\n]\n.",
  "test_cases": [
    {
      "input": "4\n5 1\n1 2\n1 3\n3 4\n2 5\n0 2 2 3 3\n1\n5 1\n4 5\n1 2\n3 1\n3 5\n0 0 2 0 2\n0\n5 2\n1 2\n1 3\n3 4\n2 5\n0 2 2 3 3\n1 3\n4 1\n1 2\n2 3\n3 4\n1 1 1 1\n1",
      "output": "2\n8\n4\n3",
      "is_sample": true
    }
  ],
  "patterns": [
    "dfs",
    "dp",
    "bit-manipulation"
  ]
}