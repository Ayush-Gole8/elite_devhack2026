{
  "title": "Sub-RBS (Hard Version)",
  "slug": "cf-2190-B2",
  "difficulty": "Medium",
  "tags": [
    "dp",
    "games",
    "implementation",
    "strings"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the hard version of the problem. The difference between the versions is that in this version, you need to find the sum of scores over all subsequences of \nğ‘ \nğ‘ \n; \nğ‘ \nğ‘ \n is not necessarily a regular bracket sequence, and the constraints on \nğ‘›\nğ‘›\n are lower.\n\nWe say that a bracket sequence \nğ‘\nğ‘\n is better than a bracket sequence \nğ‘\nğ‘\n if one of the following holds:\n\nğ‘\nğ‘\n is a prefix of \nğ‘\nğ‘\n, but \nğ‘â‰ ğ‘\nğ‘\nâ‰ \nğ‘\n; or\nlet \nğ‘–\nğ‘–\n be the first position (if it exists) where \nğ‘\nğ‘–\nâ‰ \nğ‘\nğ‘–\nğ‘\nğ‘–\nâ‰ \nğ‘\nğ‘–\n, then \nğ‘\nğ‘–\n=(\nğ‘\nğ‘–\n=\n(\n and \nğ‘\nğ‘–\n=)\nğ‘\nğ‘–\n=\n)\n.\n\nFor an arbitrary bracket sequence \nğ‘¡\nğ‘¡\n, we define its score in the following way:\n\nIf \nğ‘¡\nğ‘¡\n is not a regular bracket sequence\nâˆ—\nâˆ—\n, the score is \n0\n0\n.\nIf there exists a regular bracket subsequence \nâ€ \nâ€ \n \nğ‘Ÿ\nğ‘Ÿ\n of \nğ‘¡\nğ‘¡\n such that \nğ‘Ÿ\nğ‘Ÿ\n is better than \nğ‘¡\nğ‘¡\n, then the score is equal to the maximum value of \n|ğ‘Ÿ|\n|\nğ‘Ÿ\n|\n over all such subsequences \nğ‘Ÿ\nğ‘Ÿ\n.\nOtherwise, the score is \n0\n0\n.\n\nIn other words, the score of \nğ‘¡\nğ‘¡\n is the length of the longest regular bracket subsequence of \nğ‘¡\nğ‘¡\n which is better than \nğ‘¡\nğ‘¡\n. If \nğ‘¡\nğ‘¡\n is not a regular bracket sequence, or if no regular subsequence better than \nğ‘¡\nğ‘¡\n exists, the score is \n0\n0\n.\n\nYou are given a bracket sequence \nğ‘ \nğ‘ \n of length \nğ‘›\nğ‘›\n. Find the sum of the scores of all non-empty subsequences of \nğ‘ \nğ‘ \n modulo \n998244353\n998\n244\n353\n.\n\nâˆ—\nâˆ—\nA regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting the characters \nğŸ·\n1\n and \n+\n+\n between the original characters of the sequence. For example:\n\nbracket sequences \n()()\n()()\n and \n(())\n(())\n are regular (the resulting expressions are \n(ğŸ·)+(ğŸ·)\n(1)+(1)\n and \n((ğŸ·+ğŸ·)+ğŸ·)\n((1+1)+1)\n);\nbracket sequences \n)(\n)(\n, \n(\n(\n, and \n)\n)\n are not.\n\nâ€ \nâ€ \nA sequence \nğ‘\nğ‘\n is a subsequence of a sequence \nğ‘\nğ‘\n if \nğ‘\nğ‘\n can be obtained from \nğ‘\nğ‘\n by the deletion of several (possibly, zero or all) element from arbitrary positions.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤30\n1\nâ‰¤\nğ‘¡\nâ‰¤\n30\n). The description of the test cases follows.\n\nThe first line of each test case contains a single integer \nğ‘›\nğ‘›\n (\n1â‰¤ğ‘›â‰¤100\n1\nâ‰¤\nğ‘›\nâ‰¤\n100\n)Â â€” the length of the string \nğ‘ \nğ‘ \n.\n\nThe second line of each test case contains a sequence \nğ‘ \nğ‘ \n of length \nğ‘›\nğ‘›\n consisting only of characters \n(\n(\n and \n)\n)\n.\n\nIt is guaranteed that the sum of \nğ‘›\nğ‘›\n over all test cases does not exceed \n100\n100\n.",
  "output_format": "Output\n\nFor each test case, print a single integerÂ â€” the sum of the scores of all subsequences of \nğ‘ \nğ‘ \n, modulo \n998244353\n998\n244\n353\n.",
  "constraints": "Note\n\nIn the first example, the only non-empty subsequence is \nğ‘”=(\nğ‘”\n=\n(\n. It is not a regular bracket sequence, so its score is \n0\n0\n, and the total sum is also \n0\n0\n.\n\nIn the second example, consider \nğ‘”=ğ‘ =()()()\nğ‘”\n=\nğ‘ \n=\n()()()\n. It is a regular bracket sequence. We can choose \nğ‘Ÿ=(())\nğ‘Ÿ\n=\n(())\n, which is a subsequence of \nğ‘”\nğ‘”\n. The first index where \nğ‘Ÿ\nğ‘Ÿ\n and \nğ‘”\nğ‘”\n differ is \nğ‘–=2\nğ‘–\n=\n2\n. Since \nğ‘Ÿ\n2\n=(\nğ‘Ÿ\n2\n=\n(\n and \nğ‘”\n2\n=)\nğ‘”\n2\n=\n)\n, \nğ‘Ÿ\nğ‘Ÿ\n is better than \nğ‘”\nğ‘”\n. Hence, the score of \nğ‘”\nğ‘”\n is \n|ğ‘Ÿ|=4\n|\nğ‘Ÿ\n|\n=\n4\n. All the other non-empty subsequences of \nğ‘ \nğ‘ \n have scores equal to \n0\n0\n.",
  "test_cases": [
    {
      "input": "5\n1\n(\n6\n()()()\n6\n(())()\n8\n(())()()\n22\n()()())()()(()()()((()",
      "output": "0\n4\n0\n22\n563070",
      "is_sample": true
    }
  ]
}
