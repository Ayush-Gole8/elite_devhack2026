{
  "title": "Sub-RBS (Easy Version)",
  "slug": "cf-2190-B1",
  "difficulty": "Medium",
  "tags": [
    "combinatorics",
    "constructive algorithms",
    "dp",
    "greedy",
    "strings",
    "two pointers"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the easy version of the problem. The difference between the versions is that in this version, you only need to evaluate for whole string \nğ‘ \nğ‘ \n, \nğ‘ \nğ‘ \n is regular, and the constraints on \nğ‘›\nğ‘›\n are higher.\n\nWe say that a bracket sequence \nğ‘\nğ‘\n is better than a bracket sequence \nğ‘\nğ‘\n if one of the following holds:\n\nğ‘\nğ‘\n is a prefix of \nğ‘\nğ‘\n, but \nğ‘â‰ ğ‘\nğ‘\nâ‰ \nğ‘\n; or\nlet \nğ‘–\nğ‘–\n be the first position (if it exists) where \nğ‘\nğ‘–\nâ‰ \nğ‘\nğ‘–\nğ‘\nğ‘–\nâ‰ \nğ‘\nğ‘–\n, then \nğ‘\nğ‘–\n=(\nğ‘\nğ‘–\n=\n(\n and \nğ‘\nğ‘–\n=)\nğ‘\nğ‘–\n=\n)\n.\n\nYou are given a regular bracket sequence\nâˆ—\nâˆ—\n \nğ‘ \nğ‘ \n of even length \nğ‘›\nğ‘›\n.\n\nAmong all non-empty subsequences \nâ€ \nâ€ \n \nğ‘¡\nğ‘¡\n of \nğ‘ \nğ‘ \n that are regular bracket sequences, find the maximum possible length of \nğ‘¡\nğ‘¡\n such that \nğ‘¡\nğ‘¡\n is better than \nğ‘ \nğ‘ \n. If no such \nğ‘¡\nğ‘¡\n exists, report it.\n\nâˆ—\nâˆ—\nA regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting the characters \nğŸ·\n1\n and \n+\n+\n between the original characters of the sequence. For example:\n\nbracket sequences \n()()\n()()\n and \n(())\n(())\n are regular (the resulting expressions are \n(ğŸ·)+(ğŸ·)\n(1)+(1)\n and \n((ğŸ·+ğŸ·)+ğŸ·)\n((1+1)+1)\n);\nbracket sequences \n)(\n)(\n, \n(\n(\n, and \n)\n)\n are not.\n\nâ€ \nâ€ \nA sequence \nğ‘\nğ‘\n is a subsequence of a sequence \nğ‘\nğ‘\n if \nğ‘\nğ‘\n can be obtained from \nğ‘\nğ‘\n by the deletion of several (possibly, zero or all) element from arbitrary positions.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤\n10\n4\n1\nâ‰¤\nğ‘¡\nâ‰¤\n10\n4\n). The description of the test cases follows.\n\nThe first line of each test case contains a single integer \nğ‘›\nğ‘›\n (\n2â‰¤ğ‘›â‰¤2â‹…\n10\n5\n2\nâ‰¤\nğ‘›\nâ‰¤\n2\nâ‹…\n10\n5\n, \nğ‘›\nğ‘›\n is even)Â â€” the length of the string \nğ‘ \nğ‘ \n.\n\nThe second line of each test case contains a sequence \nğ‘ \nğ‘ \n of length \nğ‘›\nğ‘›\n consisting only of characters \n(\n(\n and \n)\n)\n.\n\nIt is guaranteed that the given sequence \nğ‘ \nğ‘ \n is a regular bracket sequence.\n\nIt is guaranteed that the sum of \nğ‘›\nğ‘›\n over all test cases does not exceed \n2â‹…\n10\n5\n2\nâ‹…\n10\n5\n.",
  "output_format": "Output\n\nFor each test case, print a single integerÂ â€” the maximum possible length of a non-empty subsequence \nğ‘¡\nğ‘¡\n of \nğ‘ \nğ‘ \n that is a regular bracket sequence and is better than \nğ‘ \nğ‘ \n. If no such \nğ‘¡\nğ‘¡\n exists, print \nâˆ’1\nâˆ’\n1\n.",
  "constraints": "Note\n\nIn the first example, the only non-empty regular bracket subsequence of \nğ‘ \nğ‘ \n is \nğ‘¡=ğ‘ =()\nğ‘¡\n=\nğ‘ \n=\n()\n. Since \nğ‘¡\nğ‘¡\n is not better than \nğ‘ \nğ‘ \n, we output \nâˆ’1\nâˆ’\n1\n.\n\nIn the second example, we can choose \nğ‘¡=((()))\nğ‘¡\n=\n((()))\n. The first index where \nğ‘¡\nğ‘¡\n and \nğ‘ \nğ‘ \n differ is \nğ‘–=3\nğ‘–\n=\n3\n. Since \nğ‘¡\n3\n=(\nğ‘¡\n3\n=\n(\n and \nğ‘ \n3\n=)\nğ‘ \n3\n=\n)\n, \nğ‘¡\nğ‘¡\n is better than \nğ‘ \nğ‘ \n. We cannot choose a longer subsequence because the only longer regular bracket subsequence is \nğ‘ \nğ‘ \n itself, which is not better than \nğ‘ \nğ‘ \n. Thus, we output \n6\n6\n.",
  "test_cases": [
    {
      "input": "3\n2\n()\n8\n(()(()))\n6\n(())()",
      "output": "-1\n6\n-1",
      "is_sample": true
    }
  ]
}
