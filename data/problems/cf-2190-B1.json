{
  "title": "Sub-RBS (Easy Version)",
  "slug": "cf-2190-B1",
  "difficulty": "Medium",
  "tags": [
    "combinatorics",
    "constructive algorithms",
    "dp",
    "greedy",
    "strings",
    "two pointers"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the easy version of the problem. The difference between the versions is that in this version, you only need to evaluate for whole string ğ‘ , ğ‘  is regular, and the constraints on ğ‘› are higher.\n\nWe say that a bracket sequence ğ‘ is better than a bracket sequence ğ‘ if one of the following holds:\n\nğ‘ is a prefix of ğ‘, but ğ‘â‰ ğ‘ğ‘â‰ ğ‘; or\nlet ğ‘– be the first position (if it exists) where ğ‘ğ‘–â‰ ğ‘ğ‘–ğ‘ğ‘–â‰ ğ‘ğ‘–, then ğ‘ğ‘–=(ğ‘ğ‘–=\n(\n and ğ‘ğ‘–=)ğ‘ğ‘–=\n)\n.\n\nYou are given a regular bracket sequence\nâˆ—\nâˆ—\n ğ‘  of even length ğ‘›.\n\nAmong all non-empty subsequences â€ \nâ€ \n ğ‘¡ of ğ‘  that are regular bracket sequences, find the maximum possible length of ğ‘¡ such that ğ‘¡ is better than ğ‘ . If no such ğ‘¡ exists, report it.\n\nâˆ—\nâˆ—\nA regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting the characters ğŸ·1 and +\n between the original characters of the sequence. For example:\n\nbracket sequences ()()\n and (())\n are regular (the resulting expressions are (ğŸ·)+(ğŸ·)(1)+(1)\n and ((ğŸ·+ğŸ·)((1+1);\nbracket sequences )(\n, (\n, and )\n are not.\n\nâ€ \nâ€ \nA sequence ğ‘ is a subsequence of a sequence ğ‘ if ğ‘ can be obtained from ğ‘ by the deletion of several (possibly, zero or all) element from arbitrary positions.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.\n\nThe first line of each test case contains a single integer ğ‘› (2â‰¤ğ‘›â‰¤2â‹…10^5, ğ‘› is even)Â â€” the length of the string ğ‘ .\n\nThe second line of each test case contains a sequence ğ‘  of length ğ‘› consisting only of characters (\n and )\n.\n\nIt is guaranteed that the given sequence ğ‘  is a regular bracket sequence.\n\nIt is guaranteed that the sum of ğ‘› over all test cases does not exceed 2â‹…10^5.",
  "output_format": "For each test case, print a single integerÂ â€” the maximum possible length of a non-empty subsequence ğ‘¡ of ğ‘  that is a regular bracket sequence and is better than ğ‘ . If no such ğ‘¡ exists, print âˆ’1\nâˆ’1.",
  "constraints": "In the first example, the only non-empty regular bracket subsequence of ğ‘  is ğ‘¡=ğ‘ =()ğ‘¡=ğ‘ =\n()\n. Since ğ‘¡ is not better than ğ‘ , we output âˆ’1\nâˆ’1.\n\nIn the second example, we can choose ğ‘¡=((()))ğ‘¡=\n((()))\n. The first index where ğ‘¡ and ğ‘  differ is ğ‘–=3. Since ğ‘¡3=(ğ‘¡3=\n(\n and ğ‘ 3=)ğ‘ 3=\n)\n, ğ‘¡ is better than ğ‘ . We cannot choose a longer subsequence because the only longer regular bracket subsequence is ğ‘  itself, which is not better than ğ‘ . Thus, we output 6.",
  "test_cases": [
    {
      "input": "3\n2\n()\n8\n(()(()))\n6\n(())()",
      "output": "-1\n6\n-1",
      "is_sample": true
    }
  ],
  "patterns": [
    "greedy",
    "dp",
    "two-pointer",
    "stack"
  ]
}