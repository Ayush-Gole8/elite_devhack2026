{
  "title": "Sub-RBS (Easy Version)",
  "slug": "cf-2190-B1",
  "difficulty": "Medium",
  "tags": [
    "combinatorics",
    "constructive algorithms",
    "dp",
    "greedy",
    "strings",
    "two pointers"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the easy version of the problem. The difference between the versions is that in this version, you only need to evaluate for whole string ğ‘ , ğ‘  is regular, and the constraints on ğ‘› are higher. \nWe say that a bracket sequence ğ‘ \n is better than a bracket sequence ğ‘ \n if one of the following holds: ğ‘ is a prefix of ğ‘, but ğ‘â‰ ğ‘ ğ‘ â‰  ğ‘ ; or let ğ‘– be the first position (if it exists) where ğ‘ ğ‘– â‰  ğ‘ ğ‘– ğ‘ ğ‘– â‰  ğ‘ ğ‘–, then ğ‘ ğ‘– =(ğ‘ ğ‘– = (and ğ‘ ğ‘– =) ğ‘ ğ‘– =). \nYou are given a regular bracket sequence âˆ— ğ‘  of even length ğ‘›. \nAmong all non-empty subsequences â€  ğ‘¡ of ğ‘  \n that are regular bracket sequences, find the maximum possible length of ğ‘¡ such that ğ‘¡ is better than ğ‘ . If no such ğ‘¡ exists, report it. âˆ— A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting the characters ğŸ· 1 and + between the original characters of the sequence. For example:\n bracket sequences ()() and (()) \n are regular (the resulting expressions are (ğŸ·)+(ğŸ·) (1)+(1) and ((ğŸ·+ğŸ·)+ğŸ·) ((1+1)+1)); bracket sequences)(, (, and) are not. â€  A sequence ğ‘ \n is a subsequence of a sequence ğ‘ if ğ‘ can be obtained from ğ‘ \n by the deletion of several (possibly, zero or all) element from arbitrary positions.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1 â‰¤ ğ‘¡ â‰¤ 10 4 1 â‰¤ ğ‘¡ â‰¤ 10 4\n). The description of the test cases follows.\n\nThe first line of each test case contains a single integer ğ‘› (2 â‰¤ ğ‘› â‰¤ 2â‹… 10 5 2 â‰¤ ğ‘› â‰¤ 2 â‹… 10 5, ğ‘› is even)Â â€” the length of the string ğ‘ . \nThe second line of each test case contains a sequence ğ‘  of length ğ‘› consisting only of characters (and).\n\nIt is guaranteed that the given sequence ğ‘  \n is a regular bracket sequence.\n\nIt is guaranteed that the sum of ğ‘› \n over all test cases does not exceed 2â‹… 10 5 2 â‹… 10 5.",
  "output_format": "Output\n\nFor each test case, print a single integerÂ â€” the maximum possible length of a non-empty subsequence ğ‘¡ of ğ‘  that is a regular bracket sequence and is better than ğ‘ . If no such ğ‘¡ exists, print -1 - 1.",
  "constraints": "Note\n\nIn the first example, the only non-empty regular bracket subsequence of ğ‘  is ğ‘¡=ğ‘ =() ğ‘¡ = ğ‘  = (). Since ğ‘¡ is not better than ğ‘ , we output -1 - 1.\n\nIn the second example, we can choose ğ‘¡=((())) ğ‘¡ = ((()))\n. The first index where ğ‘¡ and ğ‘  differ is ğ‘–=3 ğ‘– = 3. Since ğ‘¡ 3 =(ğ‘¡ 3 = (and ğ‘  3 =) ğ‘  3 =), ğ‘¡ is better than ğ‘  \n. We cannot choose a longer subsequence because the only longer regular bracket subsequence is ğ‘  \n itself, which is not better than ğ‘ . Thus, we output 6.",
  "test_cases": [
    {
      "input": "3\n2\n()\n8\n(()(()))\n6\n(())()",
      "output": "-1\n6\n-1",
      "is_sample": true
    }
  ]
}