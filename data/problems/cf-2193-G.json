{
  "title": "Paths in a Tree",
  "slug": "cf-2193-G",
  "difficulty": "Hard",
  "tags": [
    "dfs and similar",
    "interactive",
    "sortings",
    "trees"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is an interactive problem.\n\nIn this interactive problem, you are given an acyclic, connected, undirected graph consisting of ğ‘› vertices. We define a path between two vertices ğ‘£ and ğ‘¢ as a sequence of distinct vertices ğ‘1,ğ‘2,â€¦\nğ‘ğ‘˜ğ‘1,ğ‘2,â€¦\nğ‘ğ‘˜ such that ğ‘1=ğ‘£, ğ‘ğ‘˜=ğ‘¢, and for all ğ‘– (1â‰¤ğ‘–<ğ‘˜1â‰¤ğ‘–\n<\nğ‘˜), there exists an edge between vertices ğ‘ğ‘– and ğ‘ğ‘–+1.\n\nThere are hidden vertices ğ‘¥ and ğ‘¦ (they may coincide). You can make the following queries:\n\nChoose two vertices ğ‘, ğ‘ (1â‰¤ğ‘,ğ‘â‰¤ğ‘›). The jury will respond with 1 if the path between vertices ğ‘¥, ğ‘¦ and the path between vertices ğ‘, ğ‘ share at least one common vertex, and will respond with 0 otherwise.\nYour task is to find at least one vertex on the path between ğ‘¥ and ğ‘¦ in no more than âŒŠ\nğ‘›2\nâŒ‹+1\nâŒŠ\nğ‘›2\nâŒ‹\n+1 queries.\n\nNote that the interactor is adaptive, which means that the hidden vertices may change depending on your queries, but will not contradict previous queries.\nInteraction\n\nTo find any vertex on the path, you can use no more than âŒŠ\nğ‘›2\nâŒ‹+1\nâŒŠ\nğ‘›2\nâŒ‹\n+1 queries. For this, use queries of the form \"? ğ‘ ğ‘\n\".\n\nAfter each query, read one number, either 0 or 1 â€” the response to the query.\n\nWhen you find one of the required vertices, output one line in the following format: \"! ğ‘£\n\" (1â‰¤ğ‘£â‰¤ğ‘›), where ğ‘£ is the vertex you found.\n\nIf your program makes more than âŒŠ\nğ‘›2\nâŒ‹+1\nâŒŠ\nğ‘›2\nâŒ‹\n+1 queries for one test case, the response to the query will be âˆ’1\nâˆ’1, and after receiving such a response, your program should terminate immediately to receive a verdict of Incorrect answer. Otherwise, it may receive any other verdict.\n\nAfter outputting a query, do not forget to output a newline and flush the output buffer. Otherwise, you will receive a verdict of Solution \"timed out\". To flush the buffer, use:\n\nğšğš•ğšğšœğš‘(ğšœğšğšğš˜ğšğš)ğ‘“ğ‘™ğ‘¢ğ‘ \nâ„\n(ğ‘ ğ‘¡ğ‘‘ğ‘œğ‘¢ğ‘¡)\n or ğšŒğš˜ğšğš.ğšğš•ğšğšœğš‘()ğ‘ğ‘œğ‘¢ğ‘¡.ğ‘“ğ‘™ğ‘¢ğ‘ \nâ„\n()\n in C++;\nğš‚ğš¢ğšœğšğšğš–.ğš˜ğšğš.ğšğš•ğšğšœğš‘()ğ‘†ğ‘¦ğ‘ ğ‘¡ğ‘’ğ‘š.ğ‘œğ‘¢ğ‘¡.ğ‘“ğ‘™ğ‘¢ğ‘ \nâ„\n()\n in Java;\nğšğš•ğšğšœğš‘(ğš˜ğšğšğš™ğšğš)ğ‘“ğ‘™ğ‘¢ğ‘ \nâ„\n(ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡)\n in Pascal;\nğšœğšğšğš˜ğšğš.ğšğš•ğšğšœğš‘()ğ‘ ğ‘¡ğ‘‘ğ‘œğ‘¢ğ‘¡.ğ‘“ğ‘™ğ‘¢ğ‘ \nâ„\n()\n in Python;\nrefer to the documentation for other languages.",
  "input_format": "Each test consists of several test cases. The first line contains one integer ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4) â€” the number of test cases. The following lines describe the test cases.\n\nThe first line of each test case contains one integer ğ‘› (2â‰¤ğ‘›â‰¤2â‹…10^5) â€” the number of vertices in the graph.\n\nNext, there are ğ‘›âˆ’1 lines, each containing two integers ğ‘£, ğ‘¢ (1â‰¤ğ‘£,ğ‘¢â‰¤ğ‘›), indicating that vertices ğ‘£ and ğ‘¢ are connected by an edge in the graph.\n\nIt is guaranteed that the sum of ğ‘› across all test cases does not exceed 2â‹…10^5.",
  "constraints": "",
  "test_cases": [
    {
      "input": "3\n\n2\n1 2\n\n1\n\n\n3\n1 2\n1 3\n\n0\n\n0\n\n\n4\n1 2\n2 3\n2 4\n\n0\n\n1",
      "output": "? 1 1\n\n! 1\n\n\n? 1 1\n\n? 2 2\n\n! 3\n\n\n? 1 3\n\n? 4 4\n\n! 4",
      "is_sample": true
    }
  ],
  "patterns": [
    "binary-search",
    "divide-and-conquer"
  ]
}