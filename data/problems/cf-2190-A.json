{
  "title": "Sorting Game",
  "slug": "cf-2190-A",
  "difficulty": "Easy",
  "tags": [
    "constructive algorithms",
    "games",
    "greedy"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "Alice and Bob play a game on a binary string ğ‘  of length ğ‘› (a string consisting only of characters ğŸ¶0 and ğŸ·1). Alice moves first, and the players take alternate turns.\n\nIn one turn, a player chooses a sequence of indices ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘š (1â‰¤ğ‘–1\n<\nğ‘–2\n<â€¦<\nğ‘–ğ‘šâ‰¤ğ‘›1â‰¤ğ‘–1\n<\nğ‘–2\n<\nâ€¦\n<\nğ‘–ğ‘šâ‰¤ğ‘›) such that the characters at these positions form a non-increasing sequence (that is, ğ‘ ğ‘–1â‰¥ğ‘ ğ‘–2â‰¥â€¦â‰¥ğ‘ ğ‘–ğ‘šğ‘ ğ‘–1â‰¥ğ‘ ğ‘–2â‰¥\nâ€¦\nâ‰¥ğ‘ ğ‘–ğ‘š). The player then rearranges the characters at these positions to be sorted in non-decreasing order.\n\nFormally, let the chosen characters consist of ğ‘§ zeros and ğ‘œ ones (where ğ‘§+ğ‘œ=ğ‘š). The move replaces the characters at positions ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘š with a sequence of ğ‘§ zeros followed by ğ‘œ ones. A move is valid if and only if it strictly modifies the string ğ‘  (which implies ğ‘§â‰¥1 and ğ‘œâ‰¥1).\n\nThe player who cannot make a valid move loses.\n\nAssuming both players play optimally, determine the winner. If Alice wins, output a valid first move that is part of a winning strategy.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.\n\nThe first line of each test case consists of a single integer ğ‘› (1â‰¤ğ‘›â‰¤2â‹…10^5)Â â€” the length of the string ğ‘ .\n\nThe second line of each test case contains a binary string ğ‘  of length ğ‘› consisting of only characters ğŸ¶0 and ğŸ·1.\n\nIt is guaranteed that the sum of ğ‘› over all test cases does not exceed 2â‹…10^5.",
  "output_format": "For each test case, output one or three lines:\n\nIf Bob wins with optimal play, print a single line containing \"Bob\".\nOtherwise, print three lines. On the first line print \"Alice\". On the second line print an integer ğ‘š (2â‰¤ğ‘šâ‰¤ğ‘›), and on the third line print ğ‘š distinct integers ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘š (1â‰¤ğ‘–1\n<\nğ‘–2\n<â€¦<\nğ‘–ğ‘šâ‰¤ğ‘›1â‰¤ğ‘–1\n<\nğ‘–2\n<\nâ€¦\n<\nğ‘–ğ‘šâ‰¤ğ‘›)Â â€” the indices chosen for Alice's first move.\n\nThe sequence of indices you print must form a valid move according to the rules described in the statement. The indices must be printed in increasing order. If there are multiple winning moves, you may output any of them.",
  "constraints": "In the first example, there is no way to make a move after which ğ‘  will change, so Bob wins immediately.\n\nIn the third example, Alice can choose a subsequence [1,2]\n[\n1,2\n]\n and sort it, after which ğ‘  will turn into ğŸ¶ğŸ·011. After that, Bob can't make a move, so Alice wins.",
  "test_cases": [
    {
      "input": "3\n3\n000\n2\n10\n3\n101",
      "output": "Bob\nAlice\n2\n1 2 \nAlice\n2\n1 2",
      "is_sample": true
    }
  ],
  "patterns": [
    "greedy",
    "math"
  ]
}