{
  "title": "Idiot First Search and Queries",
  "slug": "cf-2195-G",
  "difficulty": "Easy",
  "tags": [
    "binary search",
    "data structures",
    "dp",
    "graphs",
    "trees"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This problem shares the definitions with problem E. However, it does not ask for the same answer.\n\nThere is a binary tree of ğ‘›+1 vertices (ğ‘› is odd), with vertices labeled 0,1,â€¦,ğ‘›. At most one letter can be written on each vertex of the tree, and all vertices initially have nothing written on them. The root of the tree is vertex 0.\n\nIn the tree, vertex 0 is the parent of vertex 1, while all other vertices have either 2 children or 0 children.\n\nBob is lost in one vertex of the tree and wishes to escape the tree by reaching vertex 0. This is very easy for most people with common sense. However, since Bob is an idiot, he created a new way of traversing the tree; introducing the \"Idiot First Search\".\n\nWhen Bob is on vertex ğ‘£ (1â‰¤ğ‘£â‰¤ğ‘›), Bob's movement is determined as follows:\n\nIf vertex ğ‘£ is a leaf, Bob always moves to the parent of ğ‘£; otherwise, check the next few conditions.\nIf nothing is written on vertex ğ‘£, Bob writes 'L' on vertex ğ‘£ and moves to the left child of ğ‘£;\nIf 'L' is written on vertex ğ‘£, Bob overwrites it to 'R' and moves to the right child of ğ‘£;\nIf 'R' is written on vertex ğ‘£, Bob erases it and moves to the parent of ğ‘£.\n\nIt takes exactly 1 second for Bob to move to an adjacent vertex, so Bob will take exactly ğ‘¥ seconds to perform ğ‘¥ moves.\n\nIt has been shown that regardless of which vertex Bob starts on, Bob can reach vertex 0 in a finite (though possibly inexplicably large) amount of time. We don't know who proved it; surely it can't be Bob, but it is definitely proven.\n\nYou are asked to answer ğ‘ queries of the following kind:\n\nğ‘£ğ‘˜\n: Assuming that Bob started from vertex ğ‘£, determine the vertex Bob is on after performing exactly ğ‘˜ moves (1â‰¤ğ‘£â‰¤ğ‘›).\n\nFor each query, let ğ‘‡ğ‘£ be the time taken to reach vertex 0 from vertex ğ‘£. Then, it is guaranteed that ğ‘˜<\nğ‘‡ğ‘£ğ‘˜\n<\nğ‘‡ğ‘£ for every query.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.\n\nThe first line of each test case contains integers ğ‘› and ğ‘ (1â‰¤ğ‘›â‰¤300001â‰¤ğ‘›â‰¤3001, 1â‰¤ğ‘â‰¤400000^1â‰¤ğ‘â‰¤4000, ğ‘› is odd).\n\nEach of the next ğ‘› lines contains two integers ğ‘™ğ‘– and ğ‘Ÿğ‘– denoting the children of vertex ğ‘– (0â‰¤ğ‘™ğ‘–,ğ‘Ÿğ‘–â‰¤ğ‘›).\n\nFor each vertex, ğ‘™ğ‘–=ğ‘Ÿğ‘–=0 is given if the vertex has no children. Otherwise, ğ‘™ğ‘– and ğ‘Ÿğ‘– are the left and right children of vertex ğ‘–.\n\nEach of the next ğ‘ lines contains two integers ğ‘£ğ‘— and ğ‘˜ğ‘— denoting the ğ‘—-th query (1â‰¤ğ‘£ğ‘—â‰¤ğ‘›, 0â‰¤ğ‘˜ğ‘—\n<min(10^9+7,ğ‘‡ğ‘£ğ‘—)0â‰¤ğ‘˜ğ‘—\n<\nmin\n(10^9+7,ğ‘‡ğ‘£ğ‘—).\n\nIt is guaranteed that the input defines a valid binary tree satisfying the conditions given in the statement.\n\nIt is guaranteed that the sum of ğ‘› over all test cases does not exceed 300001.\n\nIt is guaranteed that the sum of ğ‘ over all test cases does not exceed 400000.",
  "output_format": "For each test case, output the answers to the ğ‘ queries on a separate line.",
  "constraints": "On the first test case, there are only two vertices, vertex 0 and vertex 1. Obviously, Bob will be on vertex 1 when 0 moves have been performed after Bob started from vertex 1.\n\nOn the second test case, the tree is given as follows.\n\nIt takes 14 seconds for Bob to reach vertex 0 from vertex 3. The moves are as follows:\n\n3\nâˆ’\nâ†’\nğ™»4\nâˆ’\nâ†’\nğš‡3\nâˆ’\nâ†’\nğš5\nâˆ’\nâ†’\nğš‡3\nâˆ’\nâ†’\nğš‡1\nâˆ’\nâ†’\nğ™»2\nâˆ’\nâ†’\nğš‡1\nâˆ’\nâ†’\nğš3\nâˆ’\nâ†’\nğ™»4\nâˆ’\nâ†’\nğš‡3\nâˆ’\nâ†’\nğš5\nâˆ’\nâ†’\nğš‡3\nâˆ’\nâ†’\nğš‡1\nâˆ’\nâ†’\nğš‡03\nâ†’\nğ¿4\nâ†’\nğ‘‹3\nâ†’\nğ‘…5\nâ†’\nğ‘‹3\nâ†’\nğ‘‹1\nâ†’\nğ¿2\nâ†’\nğ‘‹1\nâ†’\nğ‘…3\nâ†’\nğ¿4\nâ†’\nğ‘‹3\nâ†’\nğ‘…5\nâ†’\nğ‘‹3\nâ†’\nğ‘‹1\nâ†’\nğ‘‹0\n\nHere, the letters above the arrows denote the letter on the vertex before moving to the adjacent vertex, where ğš‡ğ‘‹ denotes nothing written.\n\nAs highlighted in red, it is shown that:\n\nBob is on vertex 2 when 6 moves have been performed after Bob started on vertex 3;\nBob is on vertex 3 when 8 moves have been performed after Bob started on vertex 3;\nBob is on vertex 5 when 11 moves have been performed after Bob started on vertex 3.",
  "test_cases": [
    {
      "input": "3\n1 1\n0 0\n1 0\n5 5\n2 3\n0 0\n4 5\n0 0\n0 0\n3 6\n3 8\n3 11\n4 7\n5 8\n7 7\n2 3\n4 5\n0 0\n6 7\n0 0\n0 0\n0 0\n1 9\n2 18\n3 11\n3 12\n3 13\n5 7\n7 17",
      "output": "1\n2 3 5 2 1\n2 2 1 3 1 2 4",
      "is_sample": true
    }
  ],
  "patterns": [
    "dfs",
    "bfs",
    "hash-map",
    "recursion"
  ]
}