{
  "title": "The Curse of the Frog",
  "slug": "cf-2189-B",
  "difficulty": "Easy",
  "tags": [
    "constructive algorithms",
    "greedy",
    "math"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "On an infinite number line, at point 0, sits a frog. After many years of meditation, the frog has mastered ğ‘› unique types of magical jumps. The ğ‘–-th type of jump allows it to jump forward by no more than ğ‘ğ‘– units. In other words, if it was at integer point ğ‘˜, after the jump it can land at any integer point from ğ‘˜ to ğ‘˜+ğ‘ğ‘–.\n\nBut magic always comes with a price; it has been cursed. Before each ğ‘ğ‘–-th attempt (before ğ‘ğ‘–-th, 2 ğ‘ğ‘–, 3 ğ‘ğ‘– etc. attempt among the jumps of type ğ‘–) to use the ğ‘–-th type of jump, the frog rolls back ğ‘ğ‘– units! In other words, if it was at point ğ‘˜, it will first find itself at point ğ‘˜âˆ’ğ‘ğ‘–, and after the jump, it can land at any integer point from ğ‘˜âˆ’ğ‘ğ‘– to ğ‘˜âˆ’ğ‘ğ‘–+ğ‘ğ‘–.\n\nThe frog's goal is to reach the point with the number ğ‘¥, using jumps while minimizing the number of rollbacks. Help the frog â€” find the minimum number of rollbacks it will have to endure on its way to the goal, or determine that it cannot reach point ğ‘¥.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.\n\nIn the first line of each test case, there are 2 integers ğ‘› and ğ‘¥ (1â‰¤ğ‘›â‰¤10^5, 1â‰¤ğ‘¥â‰¤10^18) â€” the number of types of jumps the frog can make and its final target.\n\nIn the following ğ‘› lines, the description of the jump types is provided; the ğ‘–-th line contains 3 integers ğ‘ğ‘–, ğ‘ğ‘–, and ğ‘ğ‘– (1â‰¤ğ‘ğ‘–,ğ‘ğ‘–,ğ‘ğ‘–â‰¤10^6).\n\nIt is guaranteed that the sum of ğ‘› across all test cases does not exceed 10^5.",
  "output_format": "For each test case, if the frog can reach point ğ‘¥, find the smallest number of rollbacks it must endure to do so. If it cannot reach point ğ‘¥, output âˆ’1.",
  "constraints": "1â‰¤ğ‘›â‰¤10^5, 1â‰¤ğ‘¥â‰¤10^18, 1â‰¤ğ‘ğ‘–,ğ‘ğ‘–,ğ‘ğ‘–â‰¤10^6. Sum of ğ‘› across all test cases does not exceed 10^5.",
  "test_cases": [
    {
      "input": "10\n1 1\n3 3 3\n1 7\n4 2 5\n2 4\n1 2 3\n2 2 4\n5 8\n12 1 11\n10 1 4\n1 1 3\n1 2 5\n2 1 7\n1 100\n10 3 2\n2 10\n5 1 2\n3 1 1\n1 15\n5 2 1\n1 100\n10 5 3",
      "output": "0\n1\n-1\n2\n298892990032\n3\n6\n2\n5\n7",
      "is_sample": true,
      "explanation": "Test case 1: Target is 1, jump can go 3 units. Reach in 1 jump, 0 rollbacks.\nTest case 2: Target is 7, jump can go 4 units. Need 2 jumps of 4 and 3, but every 2nd attempt has rollback. Requires 1 rollback.\nTest case 3: Target is 4. Jump 1 goes 2 max, rollback 3. Jump 2 goes 2 max, rollback 4. Net progress with rollback is negative. Impossible.\nTest case 4: Target is 8, complex case with multiple jump types.\nTest case 5: Very large target (10^18), requires efficient greedy approach with rollback optimization.\nTest case 6: Small target with moderate parameters.\nTest case 7: Target 100 with jump of 10 max, rollback 3. Need strategic use of rollbacks.\nTest case 8: Two jump types, both no rollback on first use (b=1 means never before 1st, 2nd, 3rd...).\nTest case 9: Target 15, jump 5 max, rollback 1 every 2nd attempt.\nTest case 10: Target 100, jump 10 max, rollback 5 every 5th attempt."
    },
    {
      "input": "5\n1 1000000000000000000\n1000000 1000000 999999\n3 1000000000000000000\n999999 1 1\n500000 1 999998\n2 1\n1 1 1\n2 2 2\n1 999999999999999999\n1000000 1 0\n3 2\n1 1 1\n2 2 2\n3 3 3",
      "output": "999999000001\n999999000001\n0\n999999999999999999\n1",
      "is_sample": false,
      "explanation": "Edge case tests: Test 1: Maximum target, efficient greedy. Test 2: Multiple small jumps on huge target. Test 3: Rollback on every jump (b=1 never triggers). Test 4: Very large target with perfect jump size. Test 5: Small target with multiple options."
    }
  ],
  "notes": "Key insights:\n1. A jump of type i is 'free' (no rollback) on attempts 1, 2, ..., b_i-1, and again free on attempts b_i+1, b_i+2, ..., 2*b_i-1, etc.\n2. Attempts 1*b_i, 2*b_i, 3*b_i, ... incur a rollback of c_i before the jump.\n3. Use greedy/BFS approach: For large x, prefer jumps with better (a_i - c_i) progress ratio on rollback attempts.\n4. For very large targets, the number of rollbacks follows a mathematical pattern based on jump parameters.\n5. If max(a_i) cannot overcome max(c_i) in worst case, carefully check reachability."
}