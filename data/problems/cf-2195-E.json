{
  "title": "Idiot First Search",
  "slug": "cf-2195-E",
  "difficulty": "Easy",
  "tags": [
    "dfs and similar",
    "dp",
    "trees"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "There is a binary tree of \nğ‘›+1\nğ‘›\n+\n1\n vertices (\nğ‘›\nğ‘›\n is odd), with vertices labeled \n0,1,â€¦,ğ‘›\n0\n,\n1\n,\nâ€¦\n,\nğ‘›\n. At most one letter can be written on each vertex of the tree, and all vertices initially have nothing written on them. The root of the tree is vertex \n0\n0\n.\n\nIn the tree, vertex \n0\n0\n is the parent of vertex \n1\n1\n, while all other vertices have either \n2\n2\n children or \n0\n0\n children.\n\nBob is lost in one vertex of the tree and wishes to escape the tree by reaching vertex \n0\n0\n. This is very easy for most people with common sense. However, since Bob is an idiot, he created a new way of traversing the tree; introducing the \"Idiot First Search\".\n\nWhen Bob is on vertex \nğ‘£\nğ‘£\n (\n1â‰¤ğ‘£â‰¤ğ‘›\n1\nâ‰¤\nğ‘£\nâ‰¤\nğ‘›\n), Bob's movement is determined as follows:\n\nIf vertex \nğ‘£\nğ‘£\n is a leaf, Bob always moves to the parent of \nğ‘£\nğ‘£\n; otherwise, check the next few conditions.\nIf nothing is written on vertex \nğ‘£\nğ‘£\n, Bob writes 'L' on vertex \nğ‘£\nğ‘£\n and moves to the left child of \nğ‘£\nğ‘£\n;\nIf 'L' is written on vertex \nğ‘£\nğ‘£\n, Bob overwrites it to 'R' and moves to the right child of \nğ‘£\nğ‘£\n;\nIf 'R' is written on vertex \nğ‘£\nğ‘£\n, Bob erases it and moves to the parent of \nğ‘£\nğ‘£\n.\n\nIt takes exactly \n1\n1\n second for Bob to move to an adjacent vertex, so Bob will take exactly \nğ‘¥\nğ‘¥\n seconds to perform \nğ‘¥\nğ‘¥\n moves.\n\nIt has been shown that regardless of which vertex Bob starts on, Bob can reach vertex \n0\n0\n in a finite (though possibly inexplicably large) amount of time. We don't know who proved it; surely it can't be Bob, but it is definitely proven.\n\nFor each vertex \nğ‘˜=1,2,â€¦,ğ‘›\nğ‘˜\n=\n1\n,\n2\n,\nâ€¦\n,\nğ‘›\n, please determine the total time it takes to reach vertex \n0\n0\n if Bob started on vertex \nğ‘˜\nğ‘˜\n, in seconds. As the values may be huge, you are only asked to compute them modulo \n10\n9\n+7\n10\n9\n+\n7\n.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤\n10\n4\n1\nâ‰¤\nğ‘¡\nâ‰¤\n10\n4\n). The description of the test cases follows.\n\nThe first line of each test case contains a single integer \nğ‘›\nğ‘›\n (\n1â‰¤ğ‘›â‰¤300001\n1\nâ‰¤\nğ‘›\nâ‰¤\n300\n001\n, \nğ‘›\nğ‘›\n is odd).\n\nEach of the next \nğ‘›\nğ‘›\n lines contains two integers \nğ‘™\nğ‘–\nğ‘™\nğ‘–\n and \nğ‘Ÿ\nğ‘–\nğ‘Ÿ\nğ‘–\n denoting the children of vertex \nğ‘–\nğ‘–\n (\n0â‰¤\nğ‘™\nğ‘–\n,\nğ‘Ÿ\nğ‘–\nâ‰¤ğ‘›\n0\nâ‰¤\nğ‘™\nğ‘–\n,\nğ‘Ÿ\nğ‘–\nâ‰¤\nğ‘›\n).\n\nFor each vertex, \nğ‘™\nğ‘–\n=\nğ‘Ÿ\nğ‘–\n=0\nğ‘™\nğ‘–\n=\nğ‘Ÿ\nğ‘–\n=\n0\n is given if the vertex has no children. Otherwise, \nğ‘™\nğ‘–\nğ‘™\nğ‘–\n and \nğ‘Ÿ\nğ‘–\nğ‘Ÿ\nğ‘–\n are the left and right children of vertex \nğ‘–\nğ‘–\n.\n\nIt is guaranteed that the input defines a valid binary tree satisfying the conditions given in the statement.\n\nIt is guaranteed that the sum of \nğ‘›\nğ‘›\n over all test cases does not exceed \n300001\n300\n001\n.",
  "output_format": "Output\n\nFor each test case, output \nğ‘›\nğ‘›\n integers \nğœ\n1\n,\nğœ\n2\n,â€¦,\nğœ\nğ‘›\nğœ\n1\n,\nğœ\n2\n,\nâ€¦\n,\nğœ\nğ‘›\n separated by spaces.\n\nHere, \nğœ\nğ‘˜\nğœ\nğ‘˜\n denotes the total time it takes to reach vertex \n0\n0\n if Bob started on vertex \nğ‘˜\nğ‘˜\n, modulo \n10\n9\n+7\n10\n9\n+\n7\n.",
  "constraints": "Note\n\nOn the first test case, there are only two vertices, vertex \n0\n0\n and vertex \n1\n1\n. It takes only \n1\n1\n second for Bob to reach vertex \n0\n0\n from vertex \n1\n1\n.\n\nOn the second test case, the tree is given as follows.\n\nIt takes \n14\n14\n seconds for Bob to reach vertex \n0\n0\n from vertex \n3\n3\n. The moves are as follows:\n\n3\nâˆ’\nâ†’\nğ™»\n4\nâˆ’\nâ†’\nğš‡\n3\nâˆ’\nâ†’\nğš\n5\nâˆ’\nâ†’\nğš‡\n3\nâˆ’\nâ†’\nğš‡\n1\nâˆ’\nâ†’\nğ™»\n2\nâˆ’\nâ†’\nğš‡\n1\nâˆ’\nâ†’\nğš\n3\nâˆ’\nâ†’\nğ™»\n4\nâˆ’\nâ†’\nğš‡\n3\nâˆ’\nâ†’\nğš\n5\nâˆ’\nâ†’\nğš‡\n3\nâˆ’\nâ†’\nğš‡\n1\nâˆ’\nâ†’\nğš‡\n0\n3\nâ†’\nğ¿\n4\nâ†’\nğ‘‹\n3\nâ†’\nğ‘…\n5\nâ†’\nğ‘‹\n3\nâ†’\nğ‘‹\n1\nâ†’\nğ¿\n2\nâ†’\nğ‘‹\n1\nâ†’\nğ‘…\n3\nâ†’\nğ¿\n4\nâ†’\nğ‘‹\n3\nâ†’\nğ‘…\n5\nâ†’\nğ‘‹\n3\nâ†’\nğ‘‹\n1\nâ†’\nğ‘‹\n0\n\nHere, the letters above the arrows denote the letter on the vertex before moving to the adjacent vertex, where \nğš‡\nğ‘‹\n denotes nothing written.",
  "test_cases": [
    {
      "input": "3\n1\n0 0\n5\n2 3\n0 0\n4 5\n0 0\n0 0\n7\n2 3\n4 5\n0 0\n6 7\n0 0\n0 0\n0 0",
      "output": "1\n9 10 14 15 15\n13 22 14 27 23 28 28",
      "is_sample": true
    }
  ]
}
