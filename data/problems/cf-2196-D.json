{
  "title": "Double Bracket Sequence",
  "slug": "cf-2196-D",
  "difficulty": "Easy",
  "tags": [
    "data structures",
    "dp",
    "expression parsing",
    "flows",
    "greedy",
    "strings"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "Given a string ğ‘  of even length, consisting of the characters \"(\", \")\", \"[\" and \"]\", which are brackets of two types (round and square).\n\nWe call a string ğ‘¡ beautiful if it satisfies two conditions simultaneously:\n\nThe subsequence of all round brackets forms a correct bracket sequence\nâˆ—\nâˆ—;\nThe subsequence of all square brackets forms a correct bracket sequence.\n\nFor example, the string \"[(][)[]]()\" is beautiful, as the subsequence of all round brackets in it \"()()\" forms a correct bracket sequence and the subsequence of all square brackets in it \"[][[]]\" forms a correct bracket sequence.\n\nYou would like to turn ğ‘  into any beautiful string; for this, you can change the characters: in one operation, you can choose a position ğ‘–, such that 1â‰¤ğ‘–â‰¤ğ‘› and change the character ğ‘ ğ‘– to any round or square bracket.\n\nWhat is the minimum number of operations required to transform ğ‘  into any beautiful string?\n\nâˆ—\nâˆ—\nA bracket sequence is called correct if by inserting the symbols \"+\" and \"1\" into it, one can obtain a valid mathematical expression. For example, the sequences \"(())()\", \"[]\" and \"(()))\" are correct, while \")(\", \"[[]\" and \"(()))(\" are not.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.\n\nThe first line of each test case contains one integer ğ‘› (2â‰¤ğ‘›â‰¤2â‹…10^5)Â â€” the length of the string ğ‘ . It is guaranteed that ğ‘› is even.\n\nThe second line of each test case contains a string ğ‘  of length ğ‘›, consisting only of the characters \"(\", \")\", \"[\" and \"]\".\n\nIt is guaranteed that the sum of ğ‘› across all test cases does not exceed 2â‹…10^5",
  "output_format": "For each test case, output a single integerÂ â€” the answer to the problem.",
  "constraints": "In the first test case, from ğ‘  you can obtain \"[]\" by changing the second character.\n\nIn the second test case, from ğ‘ , in 2 operations, you can obtain \"[][]\", by changing the characters at positions 2 and 4.\n\nIn the third test case, from ğ‘ , in 2 operations, you can obtain \"()[]\", by changing the characters at positions 1 and 4.\n\nIn the fourth test case, ğ‘  is already beautiful, as it can be divided into the subsequences \"()\" and \"[]\".",
  "test_cases": [
    {
      "input": "5\n2\n[)\n4\n[)[(\n4\n))[[\n4\n([)]\n6\n[)]](]",
      "output": "1\n2\n2\n0\n2",
      "is_sample": true
    }
  ],
  "patterns": [
    "dp",
    "greedy",
    "stack"
  ]
}