{
  "title": "Again Trees... (hard version)",
  "slug": "cf-2194-F2",
  "difficulty": "Easy",
  "tags": [
    "bitmasks",
    "data structures",
    "dfs and similar",
    "dp",
    "fft",
    "trees"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the hard version of the problem. The difference between the versions is that in this version, \nğ‘˜â‰¤10\nğ‘˜\nâ‰¤\n10\n. You can hack only if you solved all versions of this problem.\n\nGiven a tree consisting of \nğ‘›\nğ‘›\n vertices. Each vertex has a non-negative integer \nğ‘\nğ‘£\nğ‘\nğ‘£\n written on it. You are also given \nğ‘˜\nğ‘˜\n distinct non-negative integers \nğ‘\n1\n,â€¦,\nğ‘\nğ‘˜\nğ‘\n1\n,\nâ€¦\n,\nğ‘\nğ‘˜\n.\n\nWe will call a set of edges beautiful if, after removing these edges from the tree, the tree splits into connected components, where in each component the bitwise XOR of all the numbers \nğ‘\nğ‘£\nğ‘\nğ‘£\n in that component belongs to the set \nğ‘\nğ‘\n.\n\nYou need to count the number of beautiful sets of edges in the tree modulo \n10\n9\n+7\n10\n9\n+\n7\n.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤500\n1\nâ‰¤\nğ‘¡\nâ‰¤\n500\n). The description of the test cases follows.\n\nThe first line of each dataset contains two integers \nğ‘›\nğ‘›\n and \nğ‘˜\nğ‘˜\n (\n2â‰¤ğ‘›â‰¤\n10\n5\n2\nâ‰¤\nğ‘›\nâ‰¤\n10\n5\n, \n1â‰¤ğ‘˜â‰¤10\n1\nâ‰¤\nğ‘˜\nâ‰¤\n10\n)Â â€” the number of vertices in the tree and the size of the set \nğ‘\nğ‘\n.\n\nThe next \nğ‘›âˆ’1\nğ‘›\nâˆ’\n1\n lines describe the edges of the tree. The \nğ‘–\nğ‘–\n-th line contains two integers \nğ‘£\nğ‘–\nğ‘£\nğ‘–\n and \nğ‘¢\nğ‘–\nğ‘¢\nğ‘–\n (\n1â‰¤\nğ‘£\nğ‘–\n,\nğ‘¢\nğ‘–\nâ‰¤ğ‘›\n1\nâ‰¤\nğ‘£\nğ‘–\n,\nğ‘¢\nğ‘–\nâ‰¤\nğ‘›\n)Â â€” the numbers of the vertices connected by the \nğ‘–\nğ‘–\n-th edge.\n\nThe next line contains \nğ‘›\nğ‘›\n integers \nğ‘\n1\n,\nğ‘\n2\n,â€¦,\nğ‘\nğ‘›\nğ‘\n1\n,\nğ‘\n2\n,\nâ€¦\n,\nğ‘\nğ‘›\n (\n0â‰¤\nğ‘\nğ‘–\n<\n2\n30\n0\nâ‰¤\nğ‘\nğ‘–\n<\n2\n30\n)Â â€” the values written on the vertices.\n\nThe following line contains \nğ‘˜\nğ‘˜\n distinct integers \nğ‘\n1\n,\nğ‘\n2\n,â€¦,\nğ‘\nğ‘˜\nğ‘\n1\n,\nğ‘\n2\n,\nâ€¦\n,\nğ‘\nğ‘˜\n (\n0â‰¤\nğ‘\nğ‘–\n<\n2\n30\n0\nâ‰¤\nğ‘\nğ‘–\n<\n2\n30\n)Â â€” the elements of the set \nğ‘\nğ‘\n.\n\nIt is guaranteed that the sum of \nğ‘›\nğ‘›\n across all datasets does not exceed \n10\n5\n10\n5\n.",
  "output_format": "Output\n\nFor each test dataset, output a single integer â€” the answer to the problem.",
  "constraints": "Note\n\nIllustration for the first test dataset. In it, you can remove the edge between vertices \n1\n1\n and \n2\n2\n. Then the bitwise XOR in the component consisting of vertices \n2\n2\n and \n5\n5\n is \nğ‘\n2\nâŠ•\nğ‘\n5\n=2âŠ•3=1\nğ‘\n2\nâŠ•\nğ‘\n5\n=\n2\nâŠ•\n3\n=\n1\n. The bitwise XOR in the component with vertices \n1\n1\n, \n3\n3\n, and \n4\n4\n is \nğ‘\n1\nâŠ•\nğ‘\n3\nâŠ•\nğ‘\n4\n=0âŠ•2âŠ•3=1\nğ‘\n1\nâŠ•\nğ‘\n3\nâŠ•\nğ‘\n4\n=\n0\nâŠ•\n2\nâŠ•\n3\n=\n1\n. The second beautiful set is the one consisting of the edge connecting vertices \n1\n1\n and \n3\n3\n.\n\nIn the third test dataset, the beautiful sets will be (an edge is denoted by the pair of vertices it connects) \n[(1,2)],[(1,3)],[(2,5)],[(3,4)]\n[\n(\n1\n,\n2\n)\n]\n,\n[\n(\n1\n,\n3\n)\n]\n,\n[\n(\n2\n,\n5\n)\n]\n,\n[\n(\n3\n,\n4\n)\n]\n. Note that the first and third samples differ only in the set \nğ‘\nğ‘\n.\n\nIn the fourth test dataset, the beautiful sets will be \n[(1,2)],[(3,4)],[(1,2),(2,3),(3,4)]\n[\n(\n1\n,\n2\n)\n]\n,\n[\n(\n3\n,\n4\n)\n]\n,\n[\n(\n1\n,\n2\n)\n,\n(\n2\n,\n3\n)\n,\n(\n3\n,\n4\n)\n]\n.",
  "test_cases": [
    {
      "input": "4\n5 1\n1 2\n1 3\n3 4\n2 5\n0 2 2 3 3\n1\n5 1\n4 5\n1 2\n3 1\n3 5\n0 0 2 0 2\n0\n5 2\n1 2\n1 3\n3 4\n2 5\n0 2 2 3 3\n1 3\n4 1\n1 2\n2 3\n3 4\n1 1 1 1\n1",
      "output": "2\n8\n4\n3",
      "is_sample": true
    }
  ]
}
