{
  "title": "Majority Wins?",
  "slug": "cf-2189-E",
  "difficulty": "Hard",
  "tags": [
    "constructive algorithms",
    "greedy",
    "math",
    "strings"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "You are given a binary string\nâˆ—\nâˆ—\n \nğ‘ \nğ‘ \n of length \nğ‘›\nğ‘›\n.\n\nIn one operation with a binary string \nğ‘”\nğ‘”\n of length \nğ‘˜\nğ‘˜\n, you can do the following:\n\nchoose some \nğ‘™,ğ‘Ÿ\nğ‘™\n,\nğ‘Ÿ\n such that \n1â‰¤ğ‘™â‰¤ğ‘Ÿâ‰¤ğ‘˜\n1\nâ‰¤\nğ‘™\nâ‰¤\nğ‘Ÿ\nâ‰¤\nğ‘˜\n;\n\nreplace the substring\nâ€ \nâ€ \n \nğ‘”\nğ‘™\n,â€¦,\nğ‘”\nğ‘Ÿ\nğ‘”\nğ‘™\n,\nâ€¦\n,\nğ‘”\nğ‘Ÿ\n of the string \nğ‘”\nğ‘”\n with one character that appears in this substring at least as many times as the other character.\n\nThe cost of such an operation will be equal to \nğ‘Ÿâˆ’ğ‘™+1\nğ‘Ÿ\nâˆ’\nğ‘™\n+\n1\n.\n\nFor example, the string 010010 can be transformed into 010 in one operation with a cost of \n4\n4\n by replacing the substring 1001 with 1; the string 1111 can be transformed into 1 by performing an operation with a cost of \n4\n4\n on the entire string, and the string 0100 can be transformed, for example, into 00 by taking the substring 100.\n\nYou need to find the minimum cost to transform the entire string \nğ‘ \nğ‘ \n into the string 1, using several (possibly none) operations, or determine that it is impossible.\n\nâˆ—\nâˆ—\nA binary string is a string that only consists of characters \n0\n0\n and \n1\n1\n.\n\nâ€ \nâ€ \nA string \nğ‘¡\nğ‘¡\n is a substring of a string \nğ‘”\nğ‘”\n if \nğ‘¡\nğ‘¡\n can be obtained from \nğ‘”\nğ‘”\n by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤\n10\n4\n1\nâ‰¤\nğ‘¡\nâ‰¤\n10\n4\n). The description of the test cases follows.\n\nThe first line of each test case contains a single integer \nğ‘›\nğ‘›\n (\n1â‰¤ğ‘›â‰¤5â‹…\n10\n5\n1\nâ‰¤\nğ‘›\nâ‰¤\n5\nâ‹…\n10\n5\n)Â â€” the length of the binary string.\n\nThe second line of each test case contains a string of length \nğ‘›\nğ‘›\n, consisting of the characters 0 and 1Â â€” the string \nğ‘ \nğ‘ \n.\n\nIt is guaranteed that the sum of \nğ‘›\nğ‘›\n over all test cases does not exceed \n5â‹…\n10\n5\n5\nâ‹…\n10\n5\n.",
  "output_format": "Output\n\nFor each test case, if it is impossible to obtain the string 1, output \nâˆ’1\nâˆ’\n1\n. Otherwise, output the minimum cost.",
  "constraints": "Note\n\nIn the first test case, it is impossible to obtain 1, since the only possible operation (\nğ‘™=ğ‘Ÿ=1\nğ‘™\n=\nğ‘Ÿ\n=\n1\n) does not change the string.\n\nIn the second test case, the string is already 1 initially, so the answer is 0.\n\nIn the fourth test case, it is possible to perform an operation on the entire string, replacing it with 1. The cost of this operation is \n2\n2\n. It can be shown that it is impossible to obtain the string 1 for a lower cost.",
  "test_cases": [
    {
      "input": "7\n1\n0\n1\n1\n2\n00\n2\n10\n3\n010\n8\n00111000\n6\n100100",
      "output": "-1\n0\n-1\n2\n4\n9\n7",
      "is_sample": true
    }
  ]
}
