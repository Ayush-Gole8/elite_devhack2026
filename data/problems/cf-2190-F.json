{
  "title": "Xor Product",
  "slug": "cf-2190-F",
  "difficulty": "Hard",
  "tags": [
    "bitmasks",
    "dp"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "For non-negative integers \nğ‘¥,ğ‘¦\nğ‘¥\n,\nğ‘¦\n and a positive integer \nğ‘˜\nğ‘˜\n, let \nğ‘†(ğ‘¥,ğ‘¦,ğ‘˜)\nğ‘†\n(\nğ‘¥\n,\nğ‘¦\n,\nğ‘˜\n)\n be the set of values \n(ğ‘¥+ğ‘–)âŠ•(ğ‘¦+ğ‘—)\n(\nğ‘¥\n+\nğ‘–\n)\nâŠ•\n(\nğ‘¦\n+\nğ‘—\n)\n for all \n0â‰¤ğ‘–,ğ‘—<ğ‘˜\n0\nâ‰¤\nğ‘–\n,\nğ‘—\n<\nğ‘˜\n. Formally:\nğ‘†(ğ‘¥,ğ‘¦,ğ‘˜)={(ğ‘¥+ğ‘–)âŠ•(ğ‘¦+ğ‘—)âˆ£0â‰¤ğ‘–,ğ‘—<ğ‘˜}\nğ‘†\n(\nğ‘¥\n,\nğ‘¦\n,\nğ‘˜\n)\n=\n{\n(\nğ‘¥\n+\nğ‘–\n)\nâŠ•\n(\nğ‘¦\n+\nğ‘—\n)\nâˆ£\n0\nâ‰¤\nğ‘–\n,\nğ‘—\n<\nğ‘˜\n}\nwhere \nâŠ•\nâŠ•\n denotes the bitwise XOR operation.\n\nDefine \nğ‘“(ğ‘¥,ğ‘˜)\nğ‘“\n(\nğ‘¥\n,\nğ‘˜\n)\n as the maximum size of \nğ‘†(ğ‘¥,ğ‘¦,ğ‘˜)\nğ‘†\n(\nğ‘¥\n,\nğ‘¦\n,\nğ‘˜\n)\n over all non-negative integers \nğ‘¦\nğ‘¦\n (that is, \nğ‘¦â‰¥0\nğ‘¦\nâ‰¥\n0\n).\n\nYou are given integers \nğ‘¥\nğ‘¥\n and \nğ‘˜\nğ‘˜\n. Compute \nğ‘“(ğ‘¥,ğ‘˜)\nğ‘“\n(\nğ‘¥\n,\nğ‘˜\n)\n.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤\n10\n4\n1\nâ‰¤\nğ‘¡\nâ‰¤\n10\n4\n). The description of the test cases follows.\n\nEach of the next \nğ‘¡\nğ‘¡\n lines contains two integers \nğ‘¥\nğ‘¥\n and \nğ‘˜\nğ‘˜\n (\n1â‰¤ğ‘¥,ğ‘˜â‰¤\n10\n17\n1\nâ‰¤\nğ‘¥\n,\nğ‘˜\nâ‰¤\n10\n17\n).",
  "output_format": "Output\n\nFor each test case, output a single integerÂ â€” the value of \nğ‘“(ğ‘¥,ğ‘˜)\nğ‘“\n(\nğ‘¥\n,\nğ‘˜\n)\n.",
  "constraints": "Note\n\nIn the first example, since \nğ‘˜=1\nğ‘˜\n=\n1\n, the set \nğ‘†\nğ‘†\n will always contain exactly one element regardless of \nğ‘¦\nğ‘¦\n. For instance, if we pick \nğ‘¦=69\nğ‘¦\n=\n69\n, we have \nğ‘†(67,69,1)={67âŠ•69}={6}\nğ‘†\n(\n67\n,\n69\n,\n1\n)\n=\n{\n67\nâŠ•\n69\n}\n=\n{\n6\n}\n, so \n|ğ‘†(ğ‘¥,ğ‘¦,ğ‘˜)|=1\n|\nğ‘†\n(\nğ‘¥\n,\nğ‘¦\n,\nğ‘˜\n)\n|\n=\n1\n.\n\nIn the second example, we have \nğ‘¥=7\nğ‘¥\n=\n7\n and \nğ‘˜=3\nğ‘˜\n=\n3\n. The optimal choice is \nğ‘¦=8\nğ‘¦\n=\n8\n. The values of \n(ğ‘¥+ğ‘–)âŠ•(ğ‘¦+ğ‘—)\n(\nğ‘¥\n+\nğ‘–\n)\nâŠ•\n(\nğ‘¦\n+\nğ‘—\n)\n are:\n[7âŠ•8,7âŠ•9,7âŠ•10,8âŠ•8,8âŠ•9,8âŠ•10,9âŠ•8,9âŠ•9,9âŠ•10]\n[\n7\nâŠ•\n8\n,\n7\nâŠ•\n9\n,\n7\nâŠ•\n10\n,\n8\nâŠ•\n8\n,\n8\nâŠ•\n9\n,\n8\nâŠ•\n10\n,\n9\nâŠ•\n8\n,\n9\nâŠ•\n9\n,\n9\nâŠ•\n10\n]\nwhich simplifies to \n[15,14,13,0,1,2,1,0,3]\n[\n15\n,\n14\n,\n13\n,\n0\n,\n1\n,\n2\n,\n1\n,\n0\n,\n3\n]\n. The set of distinct values is \nğ‘†(7,8,3)={0,1,2,3,13,14,15}\nğ‘†\n(\n7\n,\n8\n,\n3\n)\n=\n{\n0\n,\n1\n,\n2\n,\n3\n,\n13\n,\n14\n,\n15\n}\n, so the size is \n7\n7\n. It can be shown that no other \nğ‘¦\nğ‘¦\n yields a larger size. However, the choice of \nğ‘¦\nğ‘¦\n matters; for example, if you chose \nğ‘¦=22\nğ‘¦\n=\n22\n, you would get \nğ‘†(7,22,3)={16,17,30,31}\nğ‘†\n(\n7\n,\n22\n,\n3\n)\n=\n{\n16\n,\n17\n,\n30\n,\n31\n}\n with size \n4\n4\n, which is suboptimal.\n\nIn the sixth example, after countless calculations, we managed to figure out that the optimal \nğ‘¦\nğ‘¦\n is \n278302368699121665\n278\n302\n368\n699\n121\n665\n, which gives an answer of \n398158383604301822\n398\n158\n383\n604\n301\n822\n. The proof is left to the reader as a trivial exercise.",
  "test_cases": [
    {
      "input": "6\n67 1\n7 3\n100 12\n1 1043\n1526 1043\n88946092640567295 100000000000000000",
      "output": "1\n7\n32\n3128\n4167\n398158383604301822",
      "is_sample": true
    }
  ]
}
