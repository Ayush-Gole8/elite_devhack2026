{
  "title": "Fuzzy Concatenation (Easy Version)",
  "slug": "cf-2196-E1",
  "difficulty": "Easy",
  "tags": [
    "binary search",
    "bitmasks",
    "brute force",
    "data structures",
    "greedy",
    "string suffix structures"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the easy version of the problem. The difference between the versions is that in this version, ğ‘›â‰¤10^5,ğ‘šâ‰¤10^4. You can hack only if you solved all versions of this problem.\n\nThere are two strings ğ‘  and ğ‘¡, both consisting of lowercase Latin letters. You also have an empty string ğ‘.\n\nYou can perform the following operation, which consists of several stages:\n\nchoose any two integers ğ‘™ and ğ‘Ÿ (1â‰¤ğ‘™â‰¤ğ‘Ÿâ‰¤|ğ‘ |);\ncopy the substring ğ‘ ğ‘™,â€¦,ğ‘ ğ‘Ÿ and append it to the end of string ğ‘;\namong the last ğ‘Ÿâˆ’ğ‘™+1 characters of string ğ‘, change at most one character to any lowercase Latin letter.\n\nFor example, if the string ğ‘ = \"dhhtyhwbsl\" and ğ‘= \"\", you can choose ğ‘™=3,ğ‘Ÿ=6 and add \"htyh\" to the end of ğ‘, and then change the character \"y\" to \"a\", resulting in ğ‘= \"htah\".\n\nYour task is to determine the minimum number of operations required for string ğ‘ to become equal to ğ‘¡.",
  "input_format": "Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.\n\nThe first line of each test case contains two integers ğ‘› and ğ‘š (1â‰¤ğ‘›â‰¤10^5, 1â‰¤ğ‘šâ‰¤10^4)Â â€” the lengths of strings ğ‘  and ğ‘¡.\n\nThe second line of each test case contains the string ğ‘  of length ğ‘›, consisting of lowercase Latin letters.\n\nThe third line of each test case contains the string ğ‘¡ of length ğ‘š, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of ğ‘› across all test cases does not exceed 10^5, and the sum of ğ‘š across all test cases does not exceed 10^4.",
  "output_format": "For each test case, output a single integerÂ â€” the answer to the problem.",
  "constraints": "In the first test case, you can take the substring  Â«ğ‘Â»  from the string ğ‘ , change a single letter in this string to  Â«ğ‘Â» , and append it to the end of the string ğ‘, resulting in ğ‘ becoming equal to ğ‘¡.\n\nIn the second test case, ğ‘¡ can be obtained in 3 operations as follows:\n Â«ğšŠğš‹Â»+Â«ğš£Â»+Â«ğ‘ğ‘Â»+Â«ğ‘§Â»+Â«ğ‘ğ‘Â» The modified characters are highlighted in red.\n\nIn the third test case, the string ğ‘¡ can be obtained as follows:\n Â«ğš‘ğšğšŠğš‘Â»+Â«ğš‹ğšœğšÂ»+Â«â„\nğ‘¡ğ‘â„Â»+Â«ğ‘ğ‘ ğ‘’Â»+Â«â„\nğ‘¡ğ‘¦\nâ„ğ‘§ğ‘Â»",
  "test_cases": [
    {
      "input": "4\n1 1\na\nb\n5 5\naaaaa\nabzba\n10 13\ndhhtyhwbsl\nhtahbsehtyhzb\n7 2\ncontest\non",
      "output": "1\n3\n3\n1",
      "is_sample": true
    }
  ],
  "patterns": [
    "dp",
    "binary-search",
    "bit-manipulation",
    "prefix-sum"
  ]
}