{
  "title": "Interactive Graph (Simple Version)",
  "slug": "cf-2196-C1",
  "difficulty": "Easy",
  "tags": [
    "binary search",
    "combinatorics",
    "dfs and similar",
    "dp",
    "graphs",
    "interactive"
  ],
  "time_limit_ms": 2000,
  "memory_limit_kb": 256000,
  "description": "This is the simple version of the problem. The difference between the versions is that in this version, you can ask no more than \n32â‹…(ğ‘›+ğ‘š)\n32\nâ‹…\n(\nğ‘›\n+\nğ‘š\n)\n questions, and \nğ‘›â‰¤15\nğ‘›\nâ‰¤\n15\n. You can hack only if you solved all versions of this problem.\n\nThis is an interactive problem.\n\nThe jury has thought of a directed acyclic graph without loops and multiple edges, which has \nğ‘›\nğ‘›\n vertices and \nğ‘š\nğ‘š\n edges.\n\nYour task is to determine which edges are in this graph. To do this, you can ask questions of the form: what does the \nğ‘˜\nğ‘˜\n-th path look like in the lexicographically\nâˆ—\nâˆ—\n sorted list of all paths in the graph.\n\nA path in the graph is a sequence of vertices \nğ‘¢\n1\n,\nğ‘¢\n2\n,â€¦,\nğ‘¢\nğ‘™\nğ‘¢\n1\n,\nğ‘¢\n2\n,\nâ€¦\n,\nğ‘¢\nğ‘™\n, such that for any \nğ‘–<ğ‘™\nğ‘–\n<\nğ‘™\n, there exists an edge (\nğ‘¢\nğ‘–\n,\nğ‘¢\nğ‘–+1\nğ‘¢\nğ‘–\n,\nğ‘¢\nğ‘–\n+\n1\n) in the graph.\n\nYour task is to accomplish this by asking no more than \n32â‹…(ğ‘›+ğ‘š)\n32\nâ‹…\n(\nğ‘›\n+\nğ‘š\n)\n questions.\n\nâˆ—\nâˆ—\nA sequence \nğ‘\nğ‘\n is lexicographically smaller than a sequence \nğ‘\nğ‘\n if and only if one of the following holds:\n\nğ‘\nğ‘\n is a prefix of \nğ‘\nğ‘\n, but \nğ‘â‰ ğ‘\nğ‘\nâ‰ \nğ‘\n; or\nin the first position where \nğ‘\nğ‘\n and \nğ‘\nğ‘\n differ, the sequence \nğ‘\nğ‘\n has a smaller element than the corresponding element in \nğ‘\nğ‘\n.\nInteraction\n\nThe interaction for each test case begins with reading the integer \nğ‘›\nğ‘›\n.\n\nThen you can ask up to \n32â‹…(ğ‘›+ğ‘š)\n32\nâ‹…\n(\nğ‘›\n+\nğ‘š\n)\n questions.\n\nTo ask a question, output a string in the format \"? k\" (without quotes) (\n1â‰¤ğ‘˜â‰¤\n2\n30\n1\nâ‰¤\nğ‘˜\nâ‰¤\n2\n30\n). After each question, read an integer \nğ‘\nğ‘\nÂ â€” the number of vertices in the \nğ‘˜\nğ‘˜\n-th path. If \nğ‘=0\nğ‘\n=\n0\n, then such a path does not exist; otherwise, read \nğ‘\nğ‘\n integersÂ â€” the vertex numbers that make up this path.\n\nIt can be shown that under the given constraints, the number of distinct paths in the graph does not exceed \n2\n30\n2\n30\n.\n\nTo report your answer, first output a string in the format \"! m\", and then output \nğ‘š\nğ‘š\n lines describing the edges in the format \"u v\", which means that there is an edge leading from \nğ‘¢\nğ‘¢\n to \nğ‘£\nğ‘£\n. You can output the edges in any order. Outputting the answer does not count as a query.\n\nAfter printing each query do not forget to output the end of line and flush\nâˆ—\nâˆ—\n the output. Otherwise, you will get Idleness limit exceeded verdict.\n\nIf, at any interaction step, you read \nâˆ’1\nâˆ’\n1\n instead of valid data, your solution must exit immediately. This means that your solution will receive Wrong answer because of an invalid query or any other mistake. Failing to exit can result in an arbitrary verdict because your solution will continue to read from a closed stream.\n\nHacks:\n\nFor hacks, use the following format:\n\nThe first line should contain a single integer \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤10\n1\nâ‰¤\nğ‘¡\nâ‰¤\n10\n)Â â€” the number of test cases.\n\nThe first line of each case should contain two integers \nğ‘›,ğ‘š\nğ‘›\n,\nğ‘š\n (\n1â‰¤ğ‘›â‰¤15\n1\nâ‰¤\nğ‘›\nâ‰¤\n15\n, \n0â‰¤ğ‘šâ‰¤\nğ‘›â‹…(ğ‘›âˆ’1)\n2\n0\nâ‰¤\nğ‘š\nâ‰¤\nğ‘›\nâ‹…\n(\nğ‘›\nâˆ’\n1\n)\n2\n)Â â€” the number of vertices and edges in the graph.\n\nThe next \nğ‘š\nğ‘š\n lines should contain descriptions of the edges. Each edge is defined by two integers \nğ‘£\nğ‘£\n, \nğ‘¢\nğ‘¢\n (\n1â‰¤ğ‘£,ğ‘¢â‰¤ğ‘›\n1\nâ‰¤\nğ‘£\n,\nğ‘¢\nâ‰¤\nğ‘›\n, \nğ‘£â‰ ğ‘¢\nğ‘£\nâ‰ \nğ‘¢\n), meaning an edge from vertex \nğ‘£\nğ‘£\n to vertex \nğ‘¢\nğ‘¢\n.\n\nThe graph cannot contain cycles or multiple edges.\n\nâˆ—\nâˆ—\nTo flush, use:\n\nfflush(stdout) or cout.flush() in C++;\nsys.stdout.flush() in Python;\nsee the documentation for other languages.",
  "input_format": "Input\n\nEach test contains multiple test cases. The first line contains the number of test cases \nğ‘¡\nğ‘¡\n (\n1â‰¤ğ‘¡â‰¤10\n1\nâ‰¤\nğ‘¡\nâ‰¤\n10\n). The description of the test cases follows.\n\nEach test case consists of a single line with an integer \nğ‘›\nğ‘›\n (\n1â‰¤ğ‘›â‰¤15\n1\nâ‰¤\nğ‘›\nâ‰¤\n15\n)Â â€” the number of vertices in the graph.\n\nThe jury guarantees that the given graph does not contain cycles or multiple edges.\n\nNote that \nğ‘š\nğ‘š\n is unknown to you.",
  "constraints": "Note\n\nThe graph for the first test case.\n\nIn this graph, there are \n15\n15\n paths, which are arranged in lexicographic order as follows:\n\n1\n1\n1â†’2\n1\nâ†’\n2\n1â†’2â†’4\n1\nâ†’\n2\nâ†’\n4\n1â†’2â†’5\n1\nâ†’\n2\nâ†’\n5\n1â†’3\n1\nâ†’\n3\n1â†’3â†’4\n1\nâ†’\n3\nâ†’\n4\n1â†’3â†’5\n1\nâ†’\n3\nâ†’\n5\n2\n2\n2â†’4\n2\nâ†’\n4\n2â†’5\n2\nâ†’\n5\n3\n3\n3â†’4\n3\nâ†’\n4\n3â†’5\n3\nâ†’\n5\n4\n4\n5\n5",
  "test_cases": [
    {
      "input": "3\n5\n\n1 1\n\n2 1 2\n\n3 1 2 4\n\n3 1 2 5\n\n2 1 3\n\n3 1 3 4\n\n3 1 3 5\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n1\n\n0\n\n2\n\n1 1\n\n1 2\n\n2 2 1",
      "output": "? 1\n\n? 2\n\n? 3\n\n? 4\n\n? 5\n\n? 6\n\n? 7\n\n? 8\n\n? 11\n\n? 14\n\n? 15\n\n! 6\n1 3\n1 2\n2 4\n3 4\n2 5\n3 5\n\n? 2\n\n! 0\n\n? 1\n\n? 2\n\n? 3\n\n! 1\n2 1",
      "is_sample": true
    }
  ]
}
